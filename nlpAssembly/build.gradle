import groovy.json.JsonSlurper

plugins {
    id 'java'
    id("io.freefair.lombok") // version "6.3.0" // version "8.7.1"
}

group 'io.vantiq'
version 'unspecified'

java {
    sourceCompatibility = 1.11
    targetCompatibility = 1.11
}

ext {
    httpComponentVersion = '4.5.14'
}

repositories {
    mavenCentral()

    maven {
        url "https://vantiqmaven.s3.amazonaws.com/"
        metadataSources {
            // The artifact() metadataSource allows the dependency resolver to use the existence of the file
            // we want to be sufficient.  Then we don't have to publish fake POM files for our coco models
            // or image/video files.  Since this repo is used primarily to store big test objects that
            // we don't want in our GIT repo, this allows our strategy to work.  This change came during
            // upgrade to Gradle 6.x from 5.x.
            mavenPom()
            artifact()
        }
    }
}

/**
 * The following task builds an assembly project zip file for the NLP assembly.
 */

tasks.register('zipAssembly', Zip) {
    def inFiles =  project.fileTree('src/main/resources/assembly/com.vantiq.nlp.NaturalLanguageProcessing')
    logger.debug('Infiles: {}', inFiles)

    from(inFiles) {
        include '**/*'
    }

    into 'com.vantiq.nlp.NaturalLanguageProcessing'
    archiveFileName = 'natLangProcessing-assembly.zip'
}

assemble.finalizedBy zipAssembly

test {
    // set heap size for the test JVM(s)
    minHeapSize = "2048m"
    maxHeapSize = "2048m"
}

tasks.withType(Test).configureEach {
    // Use the build dir as a base to get our various test artifacts.
    systemProperty 'buildDir', layout.buildDirectory.get().asFile.absolutePath
    if (rootProject.hasProperty("TestAuthToken")) {
        systemProperty "TestAuthToken", rootProject.findProperty("TestAuthToken") ?: "empty"
    }
    if (rootProject.hasProperty("TestVantiqServer")) {
        systemProperty "TestVantiqServer", rootProject.findProperty("TestVantiqServer") ?: "empty"
    }
}

configurations {
    testResources.extendsFrom(testRuntimeOnly) // added so configurations search is allowed
}

dependencies {
    testImplementation "org.slf4j:slf4j-api:1.7.25"
    testImplementation "org.apache.logging.log4j:log4j-slf4j-impl:${log4jVersion}"
    testImplementation "org.projectlombok:lombok:${lombokVersion}"
    testImplementation 'com.fasterxml.jackson.core:jackson-databind:2.17.2'
    testImplementation "io.vantiq:vantiq-sdk:${vantiqSDKVersion}"
    testImplementation "org.apache.httpcomponents:httpclient:${httpComponentVersion}"
    testImplementation "org.apache.httpcomponents:httpclient:${httpComponentVersion}:tests"

    // Use JUnit test framework
    testImplementation 'junit:junit:4.13.1'
}


tasks.register('importAssemblies') {
    outputs.upToDateWhen { false }
    doLast {
        def importCount = 0
        def skipCount = 0
        String catalogProfile = project.rootProject.findProperty('nlpAssembliesProfile') as String
        logger.debug('Found profile: {}', catalogProfile as String)
        if (!catalogProfile?.trim()) {
            throw new GradleException('Project property "nlpAssembliesProfile" was missing or empty')
        }

        def catalogVantiqCommand = project.rootProject.findProperty("${catalogProfile}_nlpAssembliesVantiq")
        if (!catalogVantiqCommand?.trim()) {
            catalogVantiqCommand = 'vantiq'
            logger.lifecycle('Using {} as the "vantiq" command', catalogVantiqCommand)
        }

        File assemblies = new File(sourceSets.main.output.resourcesDir, "assembly")
        assemblies.eachDir { projectDir ->
            def assemblyName = projectDir.name
            def assyParts = assemblyName.split('\\.')
            logger.lifecycle('Importing {}', projectDir)

            def simpleAssemblyName = assyParts[-1]
            logger.lifecycle('Simple Assembly Name for {}: {}', assemblyName, simpleAssemblyName)

            logger.lifecycle('Importing project from {}', projectDir)
            exec {
                commandLine catalogVantiqCommand, '-s', catalogProfile, 'import', 'data', '-d', projectDir
            }
            exec {
                commandLine catalogVantiqCommand, '-s', catalogProfile, 'import', 'metadata', '-d', projectDir
            }

            importCount += 1
        }
        logger.lifecycle('Total projects imported via profile {}: {}, skipped: {}', catalogProfile, importCount,
            skipCount)
    }
}

tasks.register('publishAssemblies') {
    outputs.upToDateWhen { false }

    doLast {
        def importCount = 0
        def skipCount = 0
        String catalogProfile = project.rootProject.findProperty('nlpAssembliesProfile') as String
        logger.debug('Found profile: {}', catalogProfile as String)

        if (!catalogProfile?.trim()) {
            throw new GradleException('Project property "nlpAssembliesProfile" was missing or empty')
        }

        def catalogVantiqCommand = project.rootProject.findProperty("${catalogProfile}_nlpAssembliesVantiq")
        if (!catalogVantiqCommand?.trim()) {
            catalogVantiqCommand = 'vantiq'
            logger.lifecycle('Using {} as the "vantiq" command', catalogVantiqCommand)
        }
        def catalogName = project.rootProject.findProperty("${catalogProfile}_nlpAssembliesCatalog")
        if (!catalogName?.trim()) {
            throw new GradleException("Project property '${catalogProfile}_nlpAssembliesCatalog' was " +
                "missing" + " or empty")
        }
        def changeLog = project.rootProject.findProperty('changeLog')
        if (changeLog?.trim()) {
            // space -> _ -- passing thru many layers of scripts always turns out not quite right.
            changeLog = changeLog.replace(' ', '_')
        }

        File assemblies = new File(sourceSets.main.output.resourcesDir, "assembly")
        def projectFiles= project.fileTree(dir: assemblies, include: '**/projects/*.json')
        logger.debug('Project files: {}', projectFiles.asList())
        projectFiles.each { projectFile ->
            logger.debug("Processing project file: {}", projectFile.absolutePath)
            def projDef = new JsonSlurper().parse(projectFile)
            def assemblyName = projDef.name
            def assyParts = assemblyName.split('\\.')

            def simpleAssemblyName = assyParts[-1]
            logger.debug('Simple Assembly Name: {}', simpleAssemblyName)
            logger.info('Looking at assembly {}', assemblyName, projectFile.absolutePath)
            logger.debug('     ...from project file {}', projectFile.absolutePath)

            logger.lifecycle('Publishing assembly {} :: {}', simpleAssemblyName, assemblyName)
            logger.debug('Publishing project from {}', projectFile)
            if (!changeLog?.trim()) {
                exec {
                    commandLine catalogVantiqCommand, '-s', catalogProfile, 'run', 'procedure', 'Publisher.' +
                        'publishAssembly', 'assemblyName:' + assemblyName, 'catalogName:' + catalogName
                }
            } else {
                exec {
                    commandLine catalogVantiqCommand, '-s', catalogProfile, 'run', 'procedure', 'Publisher.' +
                        'publishAssembly', 'assemblyName:' + assemblyName, 'catalogName:' + catalogName,
                        'changeLog:' + changeLog
                }
            }
            importCount += 1

        }
        logger.lifecycle('Total projects imported via profile {}: {}, skipped: {}', catalogProfile, importCount,
            skipCount)
    }
}

publishAssemblies.mustRunAfter('importAssemblies')