group 'io.vantiq'
version 'unspecified'

apply plugin: 'java'
apply plugin: 'application'

sourceCompatibility = 1.8

repositories {
    mavenCentral()
    jcenter()
}

mainClassName = 'io.vantiq.extsrc.objectRecognition.ObjectRecognitionMain'

// Used to check if OpenCV is needed, and compile with OpenCV or throw errors if needed
// Should be "**/<source file name>.java" for every file that need openCV to run
def opencvDependentSourceFilePatterns = new ArrayList<String>(
    [
        "**/CameraRetriever.java",
        "**/FileRetriever.java",
        "**/NetworkStreamRetriever.java"
    ]
)
def opencvDependentFiles = sourceSets.main.java.matching(
        { delegate.setIncludes(opencvDependentSourceFilePatterns) }
)

// Used to automatically ignore tests for implementations that have been removed.
// The tests should be called "Test<source file name>.java"
// And should be included in the list as "**/Test<source file name>.java"
def standardImplementationTestPatterns = new ArrayList<String>(
    [
        "**/TestCameraRetriever.java",
        "**/TestFileRetriever.java",
        "**/TestYoloProcessor.java",
        "**/TestNetworkStreamRetriever",
        "**/TestFtpRetriever.java"
    ]
)

// This is the version of OpenCV that you will be using. Should be "XYZ" for version X.Y.Z
def opencvVersion = "342"

// Add the logConfig folder to the classpath so that changes to logConfig/log4j2.xml will be used for logging
// and set java.library.path to the contents of the environment variable OPENCV_LOC so the OpenCV native libraries are
// usable 
startScripts{
    doLast{
        def windowsScriptFile = file getWindowsScript()
        def unixScriptFile = file getUnixScript()
        // Add the log Config to the top of the classpath
        windowsScriptFile.text = windowsScriptFile.text.replace("CLASSPATH=", "CLASSPATH=%APP_HOME%\\logConfig;")
        unixScriptFile.text = unixScriptFile.text.replace('CLASSPATH=', 'CLASSPATH=$APP_HOME/logConfig:')
        
        if (!opencvDependentFiles.getFiles().isEmpty()) { // Only set java.library.path for OpenCV if we need it
            // Set the path to the location of the native libraries
            windowsScriptFile.text = windowsScriptFile.text.replace('DEFAULT_JVM_OPTS=', 'DEFAULT_JVM_OPTS=-Djava.library.path=%OPENCV_LOC%')
            unixScriptFile.text = unixScriptFile.text.replace('DEFAULT_JVM_OPTS=', 'DEFAULT_JVM_OPTS=-Djava.library.path=$OPENCV_LOC')
        }
    }
}

// Don't javadoc the Yolo code
javadoc.exclude("edu/*")

// Copies the README and licenses into the distribution
applicationDistribution.from(".") {
    include "README.md"
    include "LICENSE/*"
    into ""
}

// Copies the logger setup into logConfig in the distribution
applicationDistribution.from("src/main/resources") {
    include "log4j2.xml"
    into "logConfig"
}

// Downloads the large (100 MB+) video and graph files used for Yolo tests
task addTestFiles {
    // Download 'sampleVideo.mov' if it doesn't already exist
    def sampleVideoUrl = new URL("https://www.dropbox.com/s/h5yd00qr8sfgdlt/sampleVideo.mov?dl=1")
    def sampleVideoFile = file('src/test/resources/sampleVideo.mov')
    if (!sampleVideoFile.exists()) {
        sampleVideoUrl.withInputStream{ i -> sampleVideoFile.withOutputStream{ it << i }}
    }
            
    // Download 'yolo.pb' if it doesn't already exist
    def yoloGraphUrl = new URL("https://www.dropbox.com/s/lhnygcd6o6275jb/yolo.pb?dl=1")
    def yoloGraphFile = file('src/test/resources/models/yolo.pb')
    if (!yoloGraphFile.exists()) {
        yoloGraphUrl.withInputStream{ i -> yoloGraphFile.withOutputStream{ it << i }}
    }
    
}

tasks.withType(Test) {
    systemProperty "java.library.path", "${System.env.OPENCV_LOC}"
}

// Logs a warning if the .dll/.so/.dylib cannot be found for OpenCV when OpenCV is needed
assemble.doLast {
    def os = org.gradle.internal.os.OperatingSystem.current()
    // Only need to warn about missing libraries if there are files dependent on OpenCV
    if (!opencvDependentFiles.getFiles().isEmpty()) {
        if (os.isWindows()) {
            if (!file("${System.env.OPENCV_LOC}\\opencv_java${opencvVersion}.dll").exists()) {
                logger.warn("Cannot find opencv_java${opencvVersion}.dll in '${System.env.OPENCV_LOC}'. Ensure that the requested "
                    + "file exists at the folder specified in the environment variable OPENCV_LOC")
            }
        } else if (os.isLinux()) {
            if (!file("${System.env.OPENCV_LOC}/libopencv_java${opencvVersion}.so").exists()) {
                logger.warn("Cannot find libopencv_java${opencvVersion}.so in '${System.env.OPENCV_LOC}'. Ensure that the requested "
                    + "file exists at the folder specified in the environment variable OPENCV_LOC")
            }
        } else if (os.isMacOsX()) {
            if (!file("${System.env.OPENCV_LOC}/libopencv_java${opencvVersion}.dylib").exists()) {
                logger.warn("Cannot find libopencv_java${opencvVersion}.dylib in '${System.env.OPENCV_LOC}/'. Ensure that the "
                    + "requested file exists at the folder specified in the environment variable OPENCV_LOC")
            }
        } else {
            logger.warn("Compiling unknown file system. Please ensure that the compiled OpenCV C++ library is inside " 
                + "'${System.env.OPENCV_LOC}' so that the program can function correctly")
        }
    }
}

compileJava.doFirst {
    removeUnnecessaryTests()
}

// Make 'removeUnnecessaryTests' a callable function
// It makes the build not compile tests for any of the standard image retriever or neural net implementations that
// have been deleted 
ext.removeUnnecessaryTests = {

    standardImplementationTestPatterns.removeIf {
        testPattern -> 
            def testedFile = testPattern.substring(7) // Remove '**/Test' from the Pattern, leaving the tested file
            def testedFilePattern = '**/' + testedFile // Add '**/' to the tested file so it can be found in the source sets
            
            // Get all files that match "**/<source file>" which should just be the source file or nothing if the
            // source file has been removed
            def standardFile = sourceSets.main.java.matching(
                    { delegate.include(testedFilePattern) }
            )
            return !standardFile.getFiles().isEmpty() // Return true (and remove) if the file it tests still exists
    }
    // Now standardImplementationTestPatterns only contains tests for files that don't exist
    
    // Remove all tests for files that don't exist
    sourceSets.test.java.filter.exclude(standardImplementationTestPatterns)
}

processTestResources.dependsOn addTestFiles

dependencies {
    compile project(':extjsdk')
    
    compile "org.slf4j:slf4j-api:1.7.25"
    compile "org.apache.logging.log4j:log4j-slf4j-impl:2.11.0"
    

    compile "com.fasterxml.jackson.core:jackson-databind:2.9.3"
    
    // Used by YoloProcessor alone. These two dependencies and all files in the edu.* package may be removed if YoloProcessor
    // is removed
    compile "org.tensorflow:tensorflow:1.9.0"
    compile "org.apache.commons:commons-math3:3.6.1"
    
    // Used by FtpRetriever alone. Can be removed if FtpRetriever is removed
    compile "commons-net:commons-net:3.6"
    compile "com.jcraft:jsch:0.1.54"
    
    // This imports OpenCV if it is needed, and throws an error if OpenCV is needed but not properly setup
    // The opencv
    if (!opencvDependentFiles.getFiles().isEmpty()) { // Only look for OpenCV if we need it
        if (System.env.OPENCV_LOC == null ) { // Fail out if OpenCV is not available 
            // Setting depFileNames to the files still dependent on OpenCV
            def depFileNames = "'"
            opencvDependentFiles.getFiles().forEach {file -> depFileNames += file.getName() + "', '"}
            depFileNames = depFileNames.substring(0, depFileNames.length() - 3) // Remove the last ", '"
            throw new Exception("Environment variable 'OPENCV_LOC' is not set. Either set it to a location containing " + 
            "opencv-${opencvVersion}.jar and the compiled OpenCV library, or remove ${depFileNames}")
        } else if (!file("${System.env.OPENCV_LOC}/opencv-${opencvVersion}.jar").exists()) { // Fail out if the OpenCV jar is missing
            // Setting depFileNames to the files still dependent on OpenCV
            def depFileNames = "'"
            opencvDependentFiles.getFiles().forEach {file -> depFileNames += file.getName() + "', '"}
            depFileNames = depFileNames.substring(0, depFileNames.length() - 3) // Remove the last ", '"
            throw new Exception("Could not find opencv-${opencvVersion}.jar in '${System.env.OPENCV_LOC}'. Either add the jar to the "
                + "folder specified in the environment variable OPENCV_LOC or remove ${depFileNames}")
        } else {
            compile files("${System.env.OPENCV_LOC}/opencv-${opencvVersion}.jar")
        }
    }

    // Use JUnit test framework
    testCompile 'junit:junit:4.12'
    testCompile project(path:":extjsdk", configuration:"testArtifacts")
}

