plugins {
    id 'java'
    id 'application'
    id("io.freefair.lombok") // version "6.3.0" // version "8.7.1"
}

group 'io.vantiq'
version 'unspecified'

java {
    sourceCompatibility = 1.11
}

repositories {
    mavenCentral()

    maven {
        url "https://vantiqmaven.s3.amazonaws.com/"
        metadataSources {
            // The artifact() metadataSource allows the dependency resolver to use the existence of the file
            // we want to be sufficient.  Then we don't have to publish fake POM files for our coco models
            // or image/video files.  Since this repo is used primarily to store big test objects that
            // we don't want in our GIT repo, this allows our strategy to work.  This change came during
            // upgrade to Gradle 6.x from 5.x.
            mavenPom()
            artifact()
        }
    }
}

application {
    mainClassName = 'io.vantiq.extsrc.objectRecognition.ObjectRecognitionMain'
    // Copies the README and licenses into the distribution
    applicationDistribution.from(".") {
        include "README.md"
        include "LICENSE/*"
        into ""
    }

    // Copies the logger setup into logConfig in the distribution
    applicationDistribution.from("src/main/resources") {
        include "log4j2.xml"
        into "logConfig"
    }
}

// Used to automatically ignore tests for implementations that have been removed.
// The tests should be called "Test<source file name>.java"
// And should be included in the list as "**/Test<source file name>.java"
def standardImplementationTestPatterns = new ArrayList<String>(
    [
        "**/TestCameraRetriever.java",
        "**/TestFileRetriever.java",
        "**/TestYoloProcessor.java",
        "**/TestNetworkStreamRetriever.java",
        "**/TestFtpRetriever.java"
    ]
)

// Add the logConfig folder to the classpath so that changes to logConfig/log4j2.xml will be used for logging
startScripts{
    doLast{
        def windowsScriptFile = file getWindowsScript()
        def unixScriptFile = file getUnixScript()
        // Add the log Config to the top of the classpath
        windowsScriptFile.text = windowsScriptFile.text.replace("CLASSPATH=", "CLASSPATH=%APP_HOME%\\logConfig;")
        unixScriptFile.text = unixScriptFile.text.replace('CLASSPATH=', 'CLASSPATH=$APP_HOME/logConfig:')
    }
}

// Don't javadoc the Yolo code
javadoc.exclude("edu/*")

test {
    // set heap size for the test JVM(s)
    minHeapSize = "2048m"
    maxHeapSize = "2048m"
    forkEvery = 1
}

tasks.withType(Test).configureEach {
    // Use the build dir as a base to get our various test artifacts.
    systemProperty 'buildDir', layout.buildDirectory.get().asFile.absolutePath
    if (rootProject.hasProperty("TestAuthToken")) {
        systemProperty "TestAuthToken", rootProject.findProperty("TestAuthToken") ?: "empty"
    }
    if (rootProject.hasProperty("TestVantiqServer")) {
        systemProperty "TestVantiqServer", rootProject.findProperty("TestVantiqServer") ?: "empty"
    }
}

compileJava.doFirst {
    removeUnnecessaryTests()
}

// Make 'removeUnnecessaryTests' a callable function
// It makes the build not compile tests for any of the standard image retriever or neural net implementations that
// have been deleted 
ext.removeUnnecessaryTests = {

    standardImplementationTestPatterns.removeIf {
        testPattern -> 
            def testedFile = testPattern.substring(7) // Remove '**/Test' from the Pattern, leaving the tested file
            def testedFilePattern = '**/' + testedFile // Add '**/' to the tested file so it can be found in the source sets
            // Get all files that match "**/<source file>" which should just be the source file or nothing if the
            // source file has been removed
            def standardFile = sourceSets.main.java.matching(
                    { delegate.include(testedFilePattern) }
            )
            return !standardFile.getFiles().isEmpty() // Return true (and remove) if the file it tests still exists
    }
    // Now standardImplementationTestPatterns only contains tests for files that don't exist
    
    // Remove all tests for files that don't exist
    sourceSets.test.java.filter.exclude(standardImplementationTestPatterns)
}

configurations {
    testResources.extendsFrom(testRuntimeOnly) // added so configurations search is allowed
}

dependencies {
    testImplementation "org.slf4j:slf4j-api:1.7.25"
    testImplementation "org.apache.logging.log4j:log4j-slf4j-impl:${log4jVersion}"
    testImplementation "org.projectlombok:lombok:${lombokVersion}"
    testImplementation 'com.fasterxml.jackson.core:jackson-databind:2.17.2'

    // Used for uploading documents (images) to VANTIQ with VANTIQ SDK
    testImplementation "io.vantiq:vantiq-sdk:${vantiqSDKVersion}"

    // Use JUnit test framework
    testImplementation 'junit:junit:4.13.1'
    // Data to preload into our FHIR server
    testResources "vantiq.testArtifacts:fhirR4Sample:1.0@zip"
}


tasks.register('unzipSampleData', Copy) {
    def zipPath = project.configurations.testResources.find {
        it.name.startsWith("fhirR4Sample")
    }
    println zipPath
    def zipFile = file(zipPath)

    from zipTree(zipFile)
    into layout.buildDirectory.dir('sampleData')
}

tasks.register('uploadSampleData') {
    doLast {
        File dir = new File(layout.buildDirectory.dir('sampleData').get().toString())
        String fhirServer = 'http://localhost:8090/fhir'
        int loaded = 0
        int errors = 0
        int redirects = 0
        int attempts = 0
        dir.listFiles().each {sampleFile ->
            def redirectedServer = fhirServer
            try {
                attempts += 1
                for (;;) {
                    HttpURLConnection req = new URL(redirectedServer).openConnection() as HttpURLConnection
                    req.setFixedLengthStreamingMode(sampleFile.length())
                    req.setRequestMethod("POST")
                    req.setRequestProperty("Content-Type", "application/json; charset=UTF-8")
                    // Note:  If accept header isn't set (or not set to app/json or app/xml), you get HTML back,
                    // and the work isn't actually done.  Only took a day to figure that out :-(
                    req.setRequestProperty("Accept", "application/json")
                    req.setDoOutput(true)
                    req.setDoInput(true)
                    req.getOutputStream().write(sampleFile.bytes)
                    logger.debug('Uploading to {}: {}', redirectedServer, new String(sampleFile.bytes))
                    logger.info "Status code: ${req.getResponseCode()}" // HTTP request done on first read
                    switch (req.getResponseCode()) {
                        case HttpURLConnection.HTTP_MOVED_PERM:
                        case HttpURLConnection.HTTP_MOVED_TEMP:
                            def location = req.getHeaderField("Location");
                            location = URLDecoder.decode(location, "UTF-8");
                            def base = new URL(fhirServer)
                            redirectedServer = new URL(base, location).toExternalForm()  // Deal with relative URLs
                            logger.info('Redirected to {}', redirectedServer)
                            redirects += 1
                            continue

                        // Handle the set of 'it worked' conditions.  Most here should just be OK.
                        case HttpURLConnection.HTTP_OK:
                        case HttpURLConnection.HTTP_ACCEPTED:
                        case HttpURLConnection.HTTP_CREATED:
                            loaded += 1
                            break

                        default:
                            errors += 1
                            logger.error('HTTP Error loading {}: {}',
                                sampleFile.name, req.getResponseCode())
                            break
                    }
                    if (logger.isDebugEnabled()) {
                        InputStream bis = new BufferedInputStream(req.getInputStream());
                        String result = new String(bis.readAllBytes())
                        logger.debug('Result: {}', result)
                    }
                    break
                }
            } catch (Exception e) {
                logger.error('Upload of {} failed: ', sampleFile.name, e)
            }
        }
        logger.quiet('uploadSampleData: {} attempts, {} successes, {} errors, {} redirects',
                        attempts, loaded, errors, redirects)
    }
}
